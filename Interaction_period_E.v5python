{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\ncontroller_1 = Controller(PRIMARY)\ngps_7 = Gps(Ports.PORT7, -127.00, 50.80, MM, 90)\nleft_back = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\nright_back = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)\nright_front = Motor(Ports.PORT9, GearSetting.RATIO_6_1, True)\nleft_front = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nslip = Motor(Ports.PORT4, GearSetting.RATIO_18_1, False)\narm = Motor(Ports.PORT20, GearSetting.RATIO_36_1, False)\nright_rot = Rotation(Ports.PORT8, False)\nleft_rot = Rotation(Ports.PORT1, False)\narm_rot = Rotation(Ports.PORT11, False)\nMOGO_Steal = Motor(Ports.PORT14, GearSetting.RATIO_36_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\nfrom vex import *\nimport math\nimport time\n\n# Initialize the Brain\nbrain = Brain()\n\n# Drivetrain motors configuration\nright_front = Motor(Ports.PORT9, GearSetting.RATIO_6_1, True)  # Right motors reversed\nright_back = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)\nleft_front = Motor(Ports.PORT10, GearSetting.RATIO_6_1, False)\nleft_back = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\n\n# GPS sensor\ngps_7 = Gps(Ports.PORT7, -127, 50.8)  # Parameters: port, x_offset, y_offset (mm)\n\n# Robot physical specifications\nWHEEL_DIAMETER = 2.0  # inches\nWHEEL_CIRCUMFERENCE = WHEEL_DIAMETER * math.pi\nWHEELBASE = 9.0  # inches (front-to-back)\nTRACK_WIDTH = 14.0  # inches (side-to-side)\n\nclass MecanumDrive:\n    def __init__(self):\n        # Simple heading correction gain (instead of PID)\n        self.heading_correction_gain = 1.5\n        \n        # Maximum allowed heading correction\n        self.max_heading_correction = 15\n        \n        # Reset encoders\n        self.reset_drive_sensors()\n        \n    def reset_drive_sensors(self):\n        # Reset all motor encoders\n        right_front.reset_position()\n        right_back.reset_position()\n        left_front.reset_position()\n        left_back.reset_position()\n    \n    def get_average_distance(self):\n        # Calculate average distance traveled in inches\n        avg_ticks = (abs(right_front.position(DEGREES)) + \n                     abs(right_back.position(DEGREES)) + \n                     abs(left_front.position(DEGREES)) + \n                     abs(left_back.position(DEGREES))) / 4.0\n        \n        # Convert from degrees to inches\n        return (avg_ticks / 360.0) * WHEEL_CIRCUMFERENCE\n    \n    def get_heading(self):\n        # Get current heading from GPS (0-359.99 degrees)\n        heading = gps_7.heading()\n        return heading\n    \n    def set_drive_velocity(self, forward, strafe, rotate):\n        # Mecanum wheel calculations\n        front_left = forward + strafe + rotate\n        back_left = forward - strafe + rotate\n        front_right = forward - strafe - rotate\n        back_right = forward + strafe - rotate\n        \n        # Normalize velocities if any exceed 100%\n        max_raw = max(abs(front_left), abs(back_left), \n                      abs(front_right), abs(back_right))\n        \n        if max_raw > 100:\n            scale_factor = 100.0 / max_raw\n            front_left *= scale_factor\n            back_left *= scale_factor\n            front_right *= scale_factor\n            back_right *= scale_factor\n            \n        # Apply velocities to motors\n        left_front.spin(FORWARD, front_left, PERCENT)\n        left_back.spin(FORWARD, back_left, PERCENT)\n        right_front.spin(FORWARD, front_right, PERCENT)\n        right_back.spin(FORWARD, back_right, PERCENT)\n    \n    def stop_drive(self):\n        # Stop all drivetrain motors\n        left_front.stop(BRAKE)\n        left_back.stop(BRAKE)\n        right_front.stop(BRAKE)\n        right_back.stop(BRAKE)\n    \n    def drive_straight(self, distance_inches, speed=50, timeout=5000):\n        \"\"\"\n        Drive straight for a specified distance using simple heading correction\n        \n        Args:\n            distance_inches: Distance to travel in inches (positive = forward, negative = backward)\n            speed: Speed percentage (0-100)\n            timeout: Maximum time allowed for the movement in milliseconds\n        \"\"\"\n        # Reset encoders\n        self.reset_drive_sensors()\n        \n        # Get initial heading to maintain\n        target_heading = self.get_heading()\n        \n        # Direction multiplier\n        direction = 1 if distance_inches > 0 else -1\n        \n        # Set the target distance (absolute value)\n        target_distance = abs(distance_inches)\n        \n        # Timer for timeout\n        start_time = brain.timer.time(TimeUnits.MSEC)\n        \n        # Display target heading\n        brain.screen.clear_screen()\n        brain.screen.print(\"Target Heading: {:.2f}°\".format(target_heading))\n        \n        # Main control loop\n        while True:\n            # Get current distance and heading\n            current_distance = self.get_average_distance()\n            current_heading = self.get_heading()\n            \n            # Calculate heading error with wrap-around handling\n            heading_error = target_heading - current_heading\n            if heading_error > 180:\n                heading_error -= 360\n            elif heading_error < -180:\n                heading_error += 360\n                \n            # Simple proportional correction for heading\n            heading_correction = heading_error * self.heading_correction_gain\n            \n            # Limit the heading correction\n            heading_correction = max(min(heading_correction, self.max_heading_correction), \n                                    -self.max_heading_correction)\n            \n            # Set motor velocities\n            forward_power = speed * direction\n            self.set_drive_velocity(forward_power, 0, heading_correction)\n            \n            # Display feedback\n            brain.screen.set_cursor(2, 1)\n            brain.screen.print(\"Distance: {:.2f}/{:.2f}\\\"\".format(current_distance, target_distance))\n            brain.screen.set_cursor(3, 1)\n            brain.screen.print(\"Heading: {:.2f}° (Error: {:.2f}°)\".format(current_heading, heading_error))\n            \n            # Check if we've reached the target distance\n            if current_distance >= target_distance:\n                break\n                \n            # Check for timeout\n            if brain.timer.time(TimeUnits.MSEC) - start_time > timeout:\n                brain.screen.set_cursor(4, 1)\n                brain.screen.print(\"Drive timed out!\")\n                break\n            \n            # Small delay\n            wait(10, MSEC)\n        \n        # Stop the motors\n        self.stop_drive()\n        \n        # Final report\n        brain.screen.set_cursor(4, 1)\n        brain.screen.print(\"Drive complete!\")\n    \n    def strafe(self, distance_inches, speed=50, timeout=5000):\n        \"\"\"\n        Strafe for a specified distance using simple heading correction\n        \n        Args:\n            distance_inches: Distance to travel in inches (positive = right, negative = left)\n            speed: Speed percentage (0-100)\n            timeout: Maximum time allowed for the movement in milliseconds\n        \"\"\"\n        # Reset encoders\n        self.reset_drive_sensors()\n        \n        # Get initial heading to maintain\n        target_heading = self.get_heading()\n        \n        # Get initial position from GPS\n        start_x = gps_7.x_position(INCHES)\n        start_y = gps_7.y_position(INCHES)\n        \n        # Direction multiplier\n        direction = 1 if distance_inches > 0 else -1\n        \n        # Set the target distance (absolute value)\n        target_distance = abs(distance_inches)\n        \n        # Timer for timeout\n        start_time = brain.timer.time(TimeUnits.MSEC)\n        \n        # Display target heading\n        brain.screen.clear_screen()\n        brain.screen.print(\"Target Heading: {:.2f}° (Strafe)\".format(target_heading))\n        \n        # Main control loop\n        while True:\n            # Get current position from GPS\n            current_x = gps_7.x_position(INCHES)\n            current_y = gps_7.y_position(INCHES)\n            \n            # Calculate distance traveled using Pythagorean theorem\n            current_distance = math.sqrt((current_x - start_x)**2 + (current_y - start_y)**2)\n            \n            # Get current heading\n            current_heading = self.get_heading()\n            \n            # Calculate heading error with wrap-around handling\n            heading_error = target_heading - current_heading\n            if heading_error > 180:\n                heading_error -= 360\n            elif heading_error < -180:\n                heading_error += 360\n                \n            # Simple proportional correction for heading\n            heading_correction = heading_error * self.heading_correction_gain\n            \n            # Limit the heading correction\n            heading_correction = max(min(heading_correction, self.max_heading_correction), \n                                    -self.max_heading_correction)\n            \n            # Set motor velocities for strafing\n            strafe_power = speed * direction\n            self.set_drive_velocity(0, strafe_power, heading_correction)\n            \n            # Display feedback\n            brain.screen.set_cursor(2, 1)\n            brain.screen.print(\"Distance: {:.2f}/{:.2f}\\\"\".format(current_distance, target_distance))\n            brain.screen.set_cursor(3, 1)\n            brain.screen.print(\"Heading: {:.2f}° (Error: {:.2f}°)\".format(current_heading, heading_error))\n            \n            # Check if we've reached the target distance\n            if current_distance >= target_distance:\n                break\n                \n            # Check for timeout\n            if brain.timer.time(TimeUnits.MSEC) - start_time > timeout:\n                brain.screen.set_cursor(4, 1)\n                brain.screen.print(\"Strafe timed out!\")\n                break\n            \n            # Small delay\n            wait(10, MSEC)\n        \n        # Stop the motors\n        self.stop_drive()\n        \n        # Final report\n        brain.screen.set_cursor(4, 1)\n        brain.screen.print(\"Strafe complete!\")\n    \n    def turn_to_heading(self, target_heading, speed=30, timeout=3000):\n        \"\"\"\n        Turn to a specific heading\n        \n        Args:\n            target_heading: Target heading in degrees (0-359.99)\n            speed: Maximum rotation speed percentage (0-100)\n            timeout: Maximum time allowed for the turn in milliseconds\n        \"\"\"\n        # Normalize target heading to 0-359.99 range\n        target_heading = target_heading % 360\n        \n        # Timer for timeout\n        start_time = brain.timer.time(TimeUnits.MSEC)\n        \n        # Display target heading\n        brain.screen.clear_screen()\n        brain.screen.print(\"Turning to: {:.2f}°\".format(target_heading))\n        \n        # Main control loop\n        while True:\n            # Get current heading\n            current_heading = self.get_heading()\n            \n            # Calculate heading error with wrap-around handling\n            heading_error = target_heading - current_heading\n            if heading_error > 180:\n                heading_error -= 360\n            elif heading_error < -180:\n                heading_error += 360\n                \n            # If error is small enough, we're done\n            if abs(heading_error) < 2.0:  # 2-degree tolerance\n                break\n                \n            # Calculate rotation power\n            rotation_power = min(abs(heading_error) * 0.5, speed)\n            if heading_error < 0:\n                rotation_power = -rotation_power\n                \n            # Set motor velocities for turning\n            self.set_drive_velocity(0, 0, rotation_power)\n            \n            # Display feedback\n            brain.screen.set_cursor(2, 1)\n            brain.screen.print(\"Current: {:.2f}° (Error: {:.2f}°)\".format(current_heading, heading_error))\n            \n            # Check for timeout\n            if brain.timer.time(TimeUnits.MSEC) - start_time > timeout:\n                brain.screen.set_cursor(3, 1)\n                brain.screen.print(\"Turn timed out!\")\n                break\n            \n            # Small delay\n            wait(10, MSEC)\n        \n        # Stop the motors\n        self.stop_drive()\n        \n        # Final report\n        brain.screen.set_cursor(3, 1)\n        brain.screen.print(\"Turn complete!\")\n\n# Initialize the drive system\ndrive = MecanumDrive()\ndef motorVelocities(velocityPercent):\n    left_back.set_velocity(velocityPercent, PERCENT)\n    right_back.set_velocity(velocityPercent, PERCENT)\n    right_front.set_velocity(velocityPercent, PERCENT)\n    left_front.set_velocity(velocityPercent, PERCENT)\n# Example usage\ndef main():\n    # Print initial status\n    motorVelocities(75)\n    brain.screen.print(\"Robot Ready!\")\n    wait(1000, MSEC)\n    \n    \n    # red neg\n    drive.turn_to_heading(90)\n    drive.drive_straight(80)\n    for i in range(2):\n        drive.turn_to_heading(180)\n        drive.turn_to_heading(0)\n\n    drive.turn_to_heading(180)\n    drive.drive_straight(80)\n\n    for i in range(3):\n        drive.turn_to_heading(270)\n        drive.turn_to_heading(180)\n\n    drive.turn_to_heading(90)\n    drive.drive_straight(-80)\n\n    for i in range(2):\n        drive.turn_to_heading(180)\n        drive.turn_to_heading(0)\n\n    drive.turn_to_heading(180)\n    drive.drive_straight(80)\n\n    for i in range(3):\n        drive.turn_to_heading(270)\n        drive.turn_to_heading(180)\n\n    drive.drive_straight(-20)\n    drive.turn_to_heading(225)\n    drive.drive_straight(-80)\n    \n    ########################################\n    \n\n    \n    \n\n    # blue neg\n    # arm.set_position(0, DEGREES)\n    # arm.set_velocity(50, PERCENT)\n    # slip.spin(FORWARD)\n    # arm.spin_to_position(205, DEGREES, wait=True)\n    # wait(0.5,SECONDS)\n    # drive.strafe(20)\n    # drive.turn_to_heading(90, 45)\n    # slip.spin(REVERSE)\n    # slip.set_timeout(0.3, SECONDS)\n    # wait(1.5, SECONDS)\n    # arm.spin_to_position(275, DEGREES,wait=True)\n    # drive.drive_straight(48)\n    # MOGO_Steal.spin_to_position(15, DEGREES, wait=True)\n    \n\n    \n# # Uncomment to run the example sequence\nmain()\n#Strafing has small jolt","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}