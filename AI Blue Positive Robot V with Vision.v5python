{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n# AI Classification Competition Element IDs\nclass GameElements:\n    MOBILE_GOAL = 0\n    RED_RING = 1\n    BLUE_RING = 2\nleft_motor_a = Motor(Ports.PORT14, GearSetting.RATIO_6_1, False)\nleft_motor_b = Motor(Ports.PORT18, GearSetting.RATIO_6_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)\nright_motor_b = Motor(Ports.PORT13, GearSetting.RATIO_6_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 219.44, 333.375, 292.09999999999997, MM, 1)\ndigital_out_g = DigitalOut(brain.three_wire_port.g)\ndigital_out_h = DigitalOut(brain.three_wire_port.h)\ngps_5 = Gps(Ports.PORT5, 139.70, 38.10, MM, 0)\nRamp_Motor = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nintake_motor_a = Motor(Ports.PORT15, GearSetting.RATIO_18_1, True)\nintake_motor_b = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\nintake = MotorGroup(intake_motor_a, intake_motor_b)\nGyro_Sensor = Inertial(Ports.PORT21)\nright_rotation = Rotation(Ports.PORT17, False)\nleft_rotation = Rotation(Ports.PORT16, True)\ncontroller_1 = Controller(PRIMARY)\n# AI Vision Color Descriptions\nai_vision_10__Red = Colordesc(1, 241, 77, 116, 34, 0.59)\nai_vision_10__Blue = Colordesc(2, 75, 194, 239, 15, 0.32)\n# AI Vision Code Descriptions\nai_vision_10__BlueOnTop = Codedesc(1, ai_vision_10__Blue, ai_vision_10__Red)\nai_vision_10 = AiVision(Ports.PORT10, ai_vision_10__Red, ai_vision_10__Blue, ai_vision_10__BlueOnTop, AiVision.ALL_AIOBJS)\noptical_8 = Optical(Ports.PORT8)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# Import required libraries\nfrom vex import *\nimport math\n# import threading\n\nringsOnStake = 0\nfullStake = False;\n# Parameters for turning PID control\nturn_kP = 0.3     # Proportional constant\nturn_kI = 0.003   # Integral constant#.001 works for heading really well\nturn_kD = 0.4    # Derivative constant\nturn_tolerance = 2  # Acceptable error in degrees\nmin_turn_speed = 5  # Minimum turn speed to overcome friction\nmax_turn_speed = 75 # Maximum turn speed\nvisionDetects = False;\nrampSpinning = False;\nspinDirection = 0\ndef normalize_heading(heading):\n    \"\"\"Normalize heading to be between 0-360 degrees\"\"\"\n    while heading < 0:\n        heading += 360\n    while heading >= 360:\n        heading -= 360\n    return heading\n\ndef shortest_angle_difference(target, current):\n    \"\"\"Calculate the shortest angle to turn (handles wraparound)\"\"\"\n    diff = normalize_heading(target) - normalize_heading(current)\n    \n    # Handle cases where turning the other way is shorter\n    if diff > 180:\n        diff -= 360\n    elif diff < -180:\n        diff += 360\n        \n    return diff\n\ndef turn_to_heading(target_heading, max_speed):\n    \"\"\"\n    Turn the robot to a specific heading using PID control with GPS sensor\n    \n    Args:\n        target_heading: Target heading in degrees (0-360)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    print(\"Starting turn to heading: \",target_heading,\" degrees\")\n    \n    # Normalize target heading to 0-360 range\n    target_heading = normalize_heading(target_heading)\n    \n    # PID variables\n    integral = 0\n    prev_error = 0\n    \n    # Initial error calculation\n    current_heading = gps_5.heading()\n    error = shortest_angle_difference(target_heading, current_heading)\n    \n    # Continue until we're close enough to the target\n    timer = Timer()  # Used to detect if we're stuck\n    timer.reset()\n    \n    while abs(error) > turn_tolerance:\n        # Get current heading from GPS\n        current_heading = gps_5.heading()\n        \n        # Calculate error (how far we still need to turn)\n        error = shortest_angle_difference(target_heading, current_heading)\n        \n        # Calculate integral (sum of errors over time)\n        integral += error\n        \n        # Prevent integral windup\n        if abs(integral) > 1000:\n            integral = 1000 if integral > 0 else -1000\n        \n        # If we're not making progress, reset integral\n        if timer.time(SECONDS) > 2:\n            if abs(prev_error - error) < 1:\n                integral = 0\n                print(\"Progress stalled, resetting integral\")\n            timer.reset()\n        \n        # Calculate derivative (rate of change of error)\n        derivative = error - prev_error\n        \n        # Calculate motor power using PID\n        power = (error * turn_kP) + (integral * turn_kI) + (derivative * turn_kD)\n        \n        # Ensure minimum power to overcome friction\n        if 0 < abs(power) < min_turn_speed:\n            power = min_turn_speed * (1 if power > 0 else -1)\n        \n        # Limit power to specified maximum\n        if abs(power) > max_speed:\n            power = max_speed * (1 if power > 0 else -1)\n        \n        # Apply motor power for turning\n        # Positive error means we need to turn clockwise\n        left_drive_smart.spin(FORWARD, power, PERCENT)\n        right_drive_smart.spin(REVERSE, power, PERCENT)\n        \n        # Debug info\n        # print(\"Current: \",current_heading,\" Target: \",target_heading,\" Err: \",error,\" Power: \",power)\n        # print(\"GPS Position X: \",gps_5.x_position(INCHES),\" mm Y: \",gps_5.y_position(INCHES),\" mm\")\n        \n        # Update previous error for next iteration\n        prev_error = error\n        \n        # Short delay to prevent CPU hogging\n        wait(20, MSEC)\n    \n    # Stop the robot once target is reached\n    left_drive_smart.stop(BRAKE)\n    right_drive_smart.stop(BRAKE)\n    print(\"Target heading reached: Current= \",gps_5.heading(),\" Target= \",target_heading)\n\ndef turn_by_angle(angle_degrees, max_speed):\n    \"\"\"\n    Turn the robot by a relative angle using the GPS sensor\n    \n    Args:\n        angle_degrees: Angle to turn in degrees (positive=clockwise, negative=counter-clockwise)\n        max_speed: Maximum turning speed (0-100)\n    \"\"\"\n    # Get current heading\n    current_heading = gps_5.heading()\n    \n    # Calculate target heading\n    target_heading = normalize_heading(current_heading + angle_degrees)\n    \n    print(\"Starting relative turn of \",angle_degrees,\" degrees\")\n    print(\"Current heading: \",current_heading,\" Target heading: \",target_heading)\n    \n    # Execute the turn\n    turn_to_heading(target_heading, max_speed)\n    wait(100,MSEC)\n\n    if(gps_5.heading() != target_heading):\n        print (\"calling again...\\nheading: \", gps_5.heading(),\" target: \", target_heading)\n        turn_to_heading(target_heading, max_speed)\n   \n    if(gps_5.heading() != target_heading):\n        print (\"calling again...\\nheading: \", gps_5.heading(),\" target: \", target_heading)\n        turn_to_heading(target_heading, max_speed)\n\n# PID constants for straight driving correction\n# These values need tuning for your specific robot\n# kP = 0.1  # Proportional gain\n# kI = 0.01  # Integral gain\n# kD = 0.2   # Derivative gain\n\nkP = -0.01  # Proportional gain\nkI = -0.02  # Integral gain\nkD = 0.0   # Derivative gain\n\n# Maximum allowed integral value to prevent wind-up\nMAX_INTEGRAL = 50\n\n# Function to reset rotation sensors\ndef reset_rotations():\n    left_rotation.reset_position()\n    right_rotation.reset_position()\n    \n# Function to drive straight for a specific distance in degrees using PID\ndef drive_straight_pid(distance_deg, speed_pct):\n    # Reset rotation sensors\n    reset_rotations()\n    \n    # Target position and PID variables\n    target_position = abs(distance_deg)\n    direction = 1 if distance_deg > 0 else -1  # Determine direction\n    \n    # PID variables\n    prev_error = 0\n    integral = 0\n    \n    # Control loop variables\n    average_position = 0\n    last_time = brain.timer.time(MSEC)\n    \n    # Loop until we reach the target distance\n    while average_position < target_position:\n        # Calculate time delta for derivative calculation\n        \n        current_time = brain.timer.time(MSEC)\n        dt = current_time - last_time\n        dt = max(dt, 1)  # Prevent division by zero\n        last_time = current_time\n        \n        # Get current position from both rotation sensors\n        left_position = abs(left_rotation.position(DEGREES))\n        right_position = abs(right_rotation.position(DEGREES))\n        \n        # Calculate average position and error (difference between sensors)\n        average_position = (left_position + right_position) / 2\n        position_error = left_position - right_position\n        \n        # Calculate PID components\n        # Proportional term\n        p_term = position_error * kP\n        \n        # Integral term with anti-windup\n        integral += position_error * dt / 1000.0\n        integral = max(min(integral, MAX_INTEGRAL), -MAX_INTEGRAL)  # Clamp to prevent windup\n        i_term = integral * kI\n        \n        # Derivative term\n        derivative = (position_error - prev_error) / (dt / 1000.0)\n        d_term = derivative * kD\n        \n        # Calculate total correction\n        correction = p_term + i_term + d_term\n        \n        # Store error for next iteration\n        prev_error = position_error\n        \n        # Apply the correction to the motors\n        left_speed = speed_pct * direction + correction\n        right_speed = speed_pct * direction - correction\n        \n        # Constrain speeds to valid range (-100 to 100)\n        left_speed = max(min(left_speed, 100), -100)\n        right_speed = max(min(right_speed, 100), -100)\n        \n        # Set motor speeds\n        left_motor_a.spin(FORWARD, left_speed, PERCENT)\n        left_motor_b.spin(FORWARD, left_speed, PERCENT)\n        right_motor_a.spin(FORWARD, right_speed, PERCENT)\n        right_motor_b.spin(FORWARD, right_speed, PERCENT)\n        \n        # Small delay to avoid hogging CPU\n        wait(20, MSEC)\n        \n        # Display debug information\n        print(\"L: \",left_position,\" R: \",right_position,\" E: \",position_error,\" P: \",(average_position/target_position*100))\n        print(\"P: \",p_term,\" I: \",i_term,\" D: \",d_term,\"\\n\")\n        \n    # Stop all motors\n    left_motor_a.stop(BRAKE)\n    left_motor_b.stop(BRAKE)\n    right_motor_a.stop(BRAKE)\n    right_motor_b.stop(BRAKE)\n    \n    # brain.screen.set_cursor(6, 1)\n    # brain.screen.print(\"Drive complete!\")\n    print(\"Drive complete!\")\n    \n    return True\n\n# Function to aim for a specific distance and handle timeouts\ndef drive_distance_with_timeout(distance_deg, speed_pct, timeout_sec):\n     # Wait for rotation sensors to initialize\n    wait(100, MSEC)\n\n    # Start timer\n    timer = Timer()\n    \n    # Execute drive function with timeout\n    success = drive_straight_pid(distance_deg, speed_pct)\n    \n    # Check if timeout occurred\n    if timer.time(SECONDS) >= timeout_sec:\n        # brain.screen.set_cursor(7, 1)\n        # brain.screen.print(\"Drive timed out!\")\n        print(\"Drive timed out!\")\n        print(\"Drive complete!\")\n        \n        # Stop all motors\n        left_motor_a.stop(BRAKE)\n        left_motor_b.stop(BRAKE)\n        right_motor_a.stop(BRAKE)\n        right_motor_b.stop(BRAKE)\n        return False\n    \n    return success\n\ndef drive_distance_without_timeout(distance_deg, speed_pct):\n     # Wait for rotation sensors to initialize\n    wait(100, MSEC)\n\n    # Start timer\n    timer = Timer()\n    \n    # Execute drive function with timeout\n    success = drive_straight_pid(distance_deg, speed_pct)\n    \n    # Check if timeout occurred\n    # #if timer.time(SECONDS) >= timeout_sec:\n    #     # brain.screen.set_cursor(7, 1)\n    #     # brain.screen.print(\"Drive timed out!\")\n    #     print(\"Drive timed out!\")\n    #     print(\"Drive complete!\")\n        \n    #     # Stop all motors\n    #     left_motor_a.stop(BRAKE)\n    #     left_motor_b.stop(BRAKE)\n    #     right_motor_a.stop(BRAKE)\n    #     right_motor_b.stop(BRAKE)\n    #     return False\n    \n    return success\n\n\nwheelDiameter=2.75 # Inches\nwheelCircumference = math.pi * wheelDiameter\ntravelDistance = 48 # Inches\nerror = 5 # inches\n\n\ntravelDistance -= error\n\nnumberOfDegrees = (travelDistance/wheelCircumference) * 360\nspeed = 75\n\nturnAngle = 90\n\n\ndef pistonOut() :\n    digital_out_g.set(True)\n    digital_out_h.set(True)\n\ndef pistonIn() : \n    digital_out_g.set(False)\n    digital_out_h.set(False)\n\ndef intakeIn() :\n    intake_motor_a.spin(FORWARD)\n    intake_motor_b.spin(FORWARD)\n\ndef intakeOut() :\n    intake_motor_a.spin(REVERSE)\n    intake_motor_b.spin(REVERSE)\n\ndef ForwardToCoords(xGoal, yGoal) : \n    xGoal = xGoal \n    yGoal = yGoal \n    xPos = (gps_5.x_position(INCHES)) \n    yPos = (gps_5.y_position(INCHES)) \n    deg = math.sqrt((xGoal-xPos)*(xGoal-xPos)+(yGoal-yPos)*(yGoal-yPos)) \n    numberOfDegrees = (deg/wheelCircumference) * 360 \n    drive_distance_with_timeout(numberOfDegrees, 40, 100)#speed, 5)\n\ndef ReverseToCoords(xGoal, yGoal) : \n    xGoal = xGoal \n    yGoal = yGoal \n    xPos = (gps_5.x_position(INCHES)) \n    yPos = (gps_5.y_position(INCHES)) \n    deg = -math.sqrt((xGoal-xPos)*(xGoal-xPos)+(yGoal-yPos)*(yGoal-yPos)) \n    numberOfDegrees = (deg/wheelCircumference) * 360 \n    drive_distance_with_timeout(numberOfDegrees, 40, 100)#speed, 5)\n\ndef redPositiveTurnToPos(xGoal, yGoal) : \n    xGoal = xGoal \n    yGoal = yGoal\n    xPos = (gps_5.x_position(INCHES)) \n    yPos = (gps_5.y_position(INCHES)) \n    print(\"Current GPS heading: \",gps_5.heading()) \n    tol = 4 \n    if(yPos>yGoal and (xGoal+tol)>xPos and (xGoal-tol)<xPos) : \n        print(\"pos 7\") \n        turn_to_heading(180, 30) \n        print(\"pos 7\") \n    elif(yPos>yGoal and (xGoal+tol)>xPos and (xGoal-tol)<xPos) : \n        print(\"pos 8\") \n        turn_to_heading(0, 30) \n        print(\"pos 8\") \n    elif(xPos>xGoal) : \n        print(\"above\") \n        posTurn = 270-(180/math.pi)*math.atan((yGoal-yPos)/(xGoal-xPos)) \n        print(\"TurnHeading goal: \",posTurn) \n        turn_to_heading(posTurn, 30) \n        print(\"above\") \n    elif(xPos<xGoal) : \n        print(\"below\") \n        posTurn = 90-(180/math.pi)*math.atan((yGoal-yPos)/(xGoal-xPos)) \n        print(\"TurnHeading goal: \",posTurn) \n        turn_to_heading(posTurn, 30) \n\ndef xDistance(arrayElement):\n    xCenter = arrayElement.centerX\n    xDist=0.0517*xCenter -0.5137\n    return (\n        abs(xDist)\n    )\n\ndef yDistance(arrayElement) : \n    x = arrayElement.centerY\n    yDist= (-0.117)*x+27.54\n    return (yDist)\n\ndef stakeY(arrayElement) : \n    x = arrayElement.centerY\n    return 0.00432 * (x ** 2) - 0.880 * x + 54.44\ndef stakeX(arrayElement) : \n    x = arrayElement.centerX \n    xDist = (-0.1791)*x+26.5639\n    return xDist\ndef roughTurnToRingVision(arrayElement): \n    if arrayElement.id == 0 :\n        turnAngle = (180/math.pi)*math.atan(stakeX(arrayElement)/stakeY(arrayElement))\n    else:\n        turnAngle = (90/math.pi)*math.atan(xDistance(arrayElement)/yDistance(arrayElement))\n    \n\n    print(\" Vision Ring Y: \", yDistance(arrayElement))\n    print(\"Vision Ring X: \", xDistance(arrayElement))\n    print(\"Turn Angle: \", turnAngle)\n    if(arrayElement.centerX<160): \n        turn_by_angle(-turnAngle, speed)\n        #drivetrain.turn_for(LEFT, turnAngle, DEGREES)\n        print(\"turn to ring left:vision\")\n    elif(arrayElement.centerX>160): \n        turn_by_angle(-turnAngle, speed)\n        #drivetrain.turn_for(RIGHT, turnAngle, DEGREES)\n        print(\"turn to ring right: vision\")\n\ndef ringScore(arrayObj): \n    #if stake in front of ring score = 0\n    #if no stake in front, ring score = width\n    ringScore = arrayObj.width-abs(arrayObj.centerX-160)+arrayObj.centerY\n    return (ringScore)\n\ndef chooseRing(aiArray, objectIDType) : \n    pos = 0\n    bestPos = 0\n    for element in aiArray:\n        if (element.id==objectIDType) : \n            if(ringScore(element)>ringScore(aiArray[bestPos])):\n                bestPos = pos\n        pos = pos+1\n    return bestPos\n\ndef fineTurnToRingVision(arrayElement): \n    MOE = 5 #change later\n    if(160-MOE>arrayElement.centerX): \n        turn_by_angle(-3, speed)\n        #drivetrain.turn_for(LEFT, MOE, DEGREES)\n        print(\"run\")\n        drivetrain.stop()\n        return(False)\n    elif(160+MOE<arrayElement.centerX): \n        turn_by_angle(3, speed)\n        #drivetrain.turn_for(RIGHT, MOE, DEGREES)\n        print(\"run\")\n        drivetrain.stop()\n        return (False)\n    else:\n        return (True)\n    \ndef visionTurnToRing(ai_vision_10_objects, objectIDType):\n    print(\"r\")\n    if(desiredObjectExists(ai_vision_10_objects, objectIDType)):\n        roughTurnToRingVision(ai_vision_10_objects[chooseRing(ai_vision_10_objects, objectIDType)])\n        print(\"R\")\n        wait(.5, SECONDS)\n        #if 1 ring continue else choose ring\n        accurate = False;\n        while(accurate==False): \n            ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n            accurate = fineTurnToRingVision(ai_vision_10_objects[chooseRing(ai_vision_10_objects, objectIDType)])\n            print(accurate)\n            print(ai_vision_10_objects[chooseRing(ai_vision_10_objects, objectIDType)].centerX)\n            if(desiredObjectExists(ai_vision_10_objects, objectIDType)==False):\n                print(\"Ring DNE\")\n                break\n\ndef visionRingDrive(aiArray, objID):\n    xVal = ai_vision_10_objects[chooseRing(ai_vision_10_objects, objID)].centerX\n    yVal = ai_vision_10_objects[chooseRing(ai_vision_10_objects, objID)].centerY\n    travelDist = math.sqrt(xVal*xVal+yVal*yVal)\n    numberOfDegrees = (travelDist+2.5/wheelCircumference) * 360\n    drive_distance_with_timeout(numberOfDegrees, 40, 5)#speed, 5)\n\ndef desiredObjectExists(aiArray, objID):\n    for element in aiArray:\n        if(element.id == objID):\n            visionDetects = True;\n            return(True)\n    visionDetects = False\n    return(False)    \n\nringIntake = False\n\ndef onevent_optical_8_detects_object_0():\n    global ringsOnStake, fullStake\n    optical_8.set_light_power(100, PERCENT)\n    ringIntake = True\n    if optical_8.hue() < 68:\n        print(\"detected red\")\n        Ramp_Motor.stop()\n        Ramp_Motor.spin_for(FORWARD, 140, DEGREES)\n        wait(0.1, SECONDS)\n        Ramp_Motor.spin_for(REVERSE, 344, DEGREES)\n        Ramp_Motor.stop()\n        wait(.8, SECONDS)\n        Ramp_Motor.spin(FORWARD)\n        wait(1.5, SECONDS)\n        Ramp_Motor.spin(REVERSE)\n    if optical_8.hue() >= 68:\n        print(\"detected blue\")\n        wait(1.3, SECONDS)\n        Ramp_Motor.spin_for(FORWARD, 120, DEGREES)\n        Ramp_Motor.spin(REVERSE)\n        wait(.5, SECONDS)\n        currentRings = ringsOnStake;\n        ringsOnStake = currentRings+1\n        if ringsOnStake == 6: \n            Ramp_Motor.spin_for(FORWARD, 140, DEGREES)\n            Ramp_Motor.stop()\n            fullStake = True\n            ringsOnStake = 0\n        print(ringsOnStake)\n    \n\n\n# system event handlers\noptical_8.object_detected(onevent_optical_8_detects_object_0)\n# add 15ms delay to make sure events are registered correctly.\nwait(15, MSEC)\n\n\nai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\nai_vision_10_index = 0\n\ndef is_motor_stuck(motor):\n    \n    duration=0.5\n    threshold=200\n    print(\"check stuck\")\n    start_position = motor.position(DEGREES)\n    time.sleep(duration)\n    end_position = motor.position(DEGREES)\n\n    movement = abs(end_position - start_position)\n\n    if movement < threshold:\n        return (True)\n    return(False)\n\ndef monitor_motor():\n    print(\"monitor\")\n    while True:\n        #print(\"in Loop\")\n        if is_motor_stuck(Ramp_Motor)==True:\n            print(\"stuck\")\n            Ramp_Motor.stop()\n            if(spinDirection == 1): \n                Ramp_Motor.spin_for(FORWARD, 100, DEGREES)\n                wait(.1, SECONDS)\n                Ramp_Motor.spin(REVERSE)\n            if(spinDirection == -1): \n                Ramp_Motor.spin_for(REVERSE, 100, DEGREES)\n                wait(.1, SECONDS)\n                Ramp_Motor.spin(FORWARD)\n            else:\n                print(\"not spinning\")\n    wait(0.5, SECONDS)\n\ndef checkRamp():\n    while True:\n        wait(.5, SECONDS)\n        duration=0.5\n        threshold=200\n        start_position = Ramp_Motor.position(DEGREES)\n        time.sleep(duration)\n        end_position = Ramp_Motor.position(DEGREES)\n\n        movement = abs(end_position - start_position)\n\n        if movement < threshold:\n            if not spinDirection==0:\n                if(spinDirection == 1): \n                    Ramp_Motor.spin_for(FORWARD, 100, DEGREES)\n                    wait(.1, SECONDS)\n                    Ramp_Motor.spin(REVERSE)\n                if(spinDirection == -1): \n                    Ramp_Motor.spin_for(REVERSE, 100, DEGREES)\n                    wait(.1, SECONDS)\n                    Ramp_Motor.spin(FORWARD)\n            else:\n                print(\"not spinning\")\n\ndef findRingsSpin(rotAngle, rotations, objId):\n    i = 0\n    while(i<rotations):\n        ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n        while desiredObjectExists(ai_vision_10_objects, objId):\n            visionTurnToRing(ai_vision_10_objects, objId)\n            wait(.3, SECONDS)\n            x = xDistance(ai_vision_10_objects[chooseRing(ai_vision_10_objects, objId)])\n            y = yDistance(ai_vision_10_objects[chooseRing(ai_vision_10_objects, objId)])\n            DriveDist = math.sqrt(x*x+y*y)\n            visionRingDrive(ai_vision_10_objects, objId)\n            wait(.5, SECONDS)\n            numberOfDegrees = (-DriveDist/wheelCircumference) * 360\n            drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n            ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n        turn_by_angle(rotAngle, speed)\n\n# ringsOnStake = 0\n\ndef stakeScore(aiArray, arrayObj): \n    stakeRings = stakeRingCount(aiArray, arrayObj)\n    if stakeRings == 0: \n        stakeRings = 0.5\n    stakeScore = arrayObj.width-abs(arrayObj.centerX-160)+arrayObj.centerY/stakeRings\n    return(stakeScore)\n\ndef stakeRingCount(aiArray, arrayObj):\n    stakeRings = 0\n    if(desiredObjectExists(aiArray, 0)): \n        stakeX = arrayObj.centerX\n        stakeY = arrayObj.centerY\n        for element in aiArray:\n            if element.centerX<stakeX+10 and element.centerX>stakeX-10 and element.centerY< stakeY and (not element.id==0): \n                stakeRings = stakeRings + 1        \n  \n    return (stakeRings)\n\ndef goodStake(aiArray, arrayObj):\n    stakeRings = stakeRingCount(aiArray, arrayObj)\n    if (stakeRings<6):\n        return (True)\n    return(False)\n\ndef chooseStake(aiArray) : \n    bestPos = 0\n    pos = 0\n    for element in aiArray:\n        if (element.id==0) : \n            if goodStake(aiArray, element):\n                bestPos = pos\n                break\n        pos = pos+1\n    pos = 0\n    for element in aiArray:\n        if (element.id==0) : \n            if(stakeScore(aiArray, element)>stakeScore(aiArray, aiArray[bestPos])):\n                if goodStake(aiArray, element):\n                    bestPos = pos\n        pos = pos+1\n    if(not goodStake(aiArray, aiArray[bestPos])):\n        bestPos = -1;\n    return bestPos\n\ndef visionTurnToStake(ai_vision_10_objects):\n    if(desiredObjectExists(ai_vision_10_objects, 0)):\n        if (not chooseStake(ai_vision_10_objects)==-1):\n            roughTurnToRingVision(ai_vision_10_objects[chooseStake(ai_vision_10_objects)])\n            wait(.5, SECONDS)\n            accurate = False;\n            while(accurate==False): \n                ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n                accurate = fineTurnToRingVision(ai_vision_10_objects[chooseStake(ai_vision_10_objects)])\n                print(accurate)\n                print(ai_vision_10_objects[chooseStake(ai_vision_10_objects)].centerX)\n                if(desiredObjectExists(ai_vision_10_objects, 0)==False):\n                    print(\"Ring DNE\")\n                    break\n        \nclass searchCoords:\n    def __init__(self, xCoord, yCoord, nextHeading):\n        self.xCoordinate = xCoord\n        self.yCoordinate = yCoord\n        self.nextHeading = nextHeading\n    \n    def getX(self):\n        return self.xCoordinate\n    def getY(self):\n        return self.yCoordinate\n    def getNext(self):\n        return self.nextHeading\n\nstartCoords = [\n    searchCoords(40, 40, 180), \n    searchCoords(-40, 40, 90), \n    searchCoords(-40, -40, 0), \n    searchCoords(40, -40, 270), \n]\n\ndef startSearchPoint():\n    closestDist = 200\n    bestStart = searchCoords(0, 0, 45)\n    for element in startCoords:\n        currentX = gps_5.x_position(INCHES)\n        currentY = gps_5.y_position(INCHES)\n        x = element.getX()\n        y = element.getY()\n        travelDist = math.sqrt((x-currentX)**2+(y-currentY)**2)\n        if (travelDist<closestDist): \n            bestStart = element\n    return bestStart\n\ndef checkStakeObstructions(aiArray):\n    stake = aiArray[chooseStake(aiArray)]\n    for element in aiArray:\n        if(not element.id==0):\n            if (stake.centerY<element.centerY and (stake.centerX+70>element.centerX or stake.centerX-70<element.centerX)):\n                return (True)            \n    return (False)\n\ndef removeObstructions(element):\n    intake.spin(FORWARD)\n    Ramp_Motor.spin(REVERSE)\n    xDist = xDistance(element)\n    yDist = yDistance(element)\n    # makeshift roughTurnToRing\n    turnDegrees = 0\n    if (element.centerX<160):\n        turnDegrees = abs(math.atan(xDist/yDist))\n    elif (element.centerX>160):\n        turnDegrees = -abs(math.atan(xDist/yDist))\n    turn_by_angle(turnDegrees, speed)\n    wait(.2, SECONDS)\n    #align with the ring\n    ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    visionTurnToRing(ai_vision_10_objects, element.id)\n    wait(.2, SECONDS)\n    #drives to intake ring\n    ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    driveDist = yDistance((chooseRing(ai_vision_10_objects, element.id)))\n    visionRingDrive(ai_vision_10_objects, element.id)\n    wait(.2, SECONDS)\n    # drives back\n    numberOfDegrees = (-driveDist/wheelCircumference) * 360\n    drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n    wait(.2, SECONDS)\n    #Turn back to face the stake\n    turn_by_angle(-turnDegrees, speed)\n    wait(.2, SECONDS)\n    #takes snapshot\n    #ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    #visionTurnToStake(ai_vision_10_objects)\n    #wait(.2, SECONDS)\n                \n\ndef spinForStake(rotAngle, rotations):\n    i = 0\n    #angleRotated = 0\n    while(i<rotations): \n        ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n        while desiredObjectExists(ai_vision_10_objects, 0):\n            visionTurnToStake(ai_vision_10_objects)\n            while(checkStakeObstructions(ai_vision_10_objects)):\n                stake = ai_vision_10_objects[chooseStake(ai_vision_10_objects)]\n                for element in ai_vision_10_objects:\n                    #if element is a ring\n                    if(not element.id==0):\n                        #If the ring is in the way of the stake\n                        if (stake.centerY<element.centerY and (stake.centerX+70>element.centerX or stake.centerX-70<element.centerX)):\n                            removeObstructions(element)\n                            ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n                            visionTurnToStake(ai_vision_10_objects)\n                            ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n                            break\n                    \n                ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n\n            ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n            visionTurnToStake(ai_vision_10_objects)\n            return (True)\n\n        turn_by_angle(rotAngle, speed)\n        i = i+1\n        #angleRotated = angleRotated+rotAngle\n    \n    return(False)\n            \n# def findStake():\n#     hasStake = False\n#     x = startSearchPoint().getX()\n#     y = startSearchPoint().getY()\n#     redPositiveTurnToPos(x, y)\n#     ForwardToCoords(x, y)\n#     turn_to_heading(startSearchPoint().getNext(), speed) \n#     hasStake = findStakeSpin(45, 8)\n#     i = 0\n#     while(i<4 or hasStake == False):\n#         i = i+1\n#         numberOfDegrees = (40/wheelCircumference) * 360\n#         drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n#         hasStake = findStakeSpin(45, 8)\n#         if not hasStake:\n#             numberOfDegrees = (40/wheelCircumference) * 360\n#             drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n#             hasStake = findStakeSpin(45, 10)\n#     if(hasStake):\n#         turn_by_angle(180, speed)\n        \n#         return (True)\n#     else:\n#         print(\"No Stake Found\")\n#         return (False)    \n\ndef timeForDistance(travelDistance) :\n    travelTime = 0.013763*travelDistance + 0.325757\n    return (travelTime)\n\n# Main program\ndef main():\n    global ai_vision_10_objects, ai_vision_10_index, ringsOnStake, fullStake, spinDirection\n    rampSpinning = True\n    #monitor_thread = Event(monitor_motor)\n    #monitor_thread.broadcast()\n    spinDirection = 0\n    # checkRamp()\n    #Fill stake1Coords = []\n    \n    # print (\"monitor_thread: \", monitor_thread)\n    # # Set as daemon threads so they exit when the main program exits\n    # monitor_thread.daemon = True\n    \n    # # Start the threads\n    # monitor_thread.start()\n    #monitor_thread = brain.task.spawn(monitor_motor)\n    #gps_5.calibrate()\n    print(\"Starting GPS navigation program\")\n    print(\"Current GPS heading: \",gps_5.heading())\n    print(\"Current GPS position: X= \",gps_5.x_position(INCHES), \" IN Y= \",gps_5.y_position(INCHES),\" IN\")\n    \n    # Allow GPS to calibrate if needed\n    intake_motor_a.set_velocity(100, PERCENT)\n    intake_motor_b.set_velocity(100, PERCENT)\n    Ramp_Motor.set_velocity(100, PERCENT)\n    pistonOut()\n    wait(5, SECONDS)\n\n    # Wait for user to press a button to start\n    print(\"Running Auto\")\n    print(\"Rings On Stake = \", ringsOnStake)\n\n    # ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    # visionTurnToStake(ai_vision_10_objects)\n    \n    # drivetrain.set_drive_velocity(100, PERCENT)\n    # drivetrain.set_stopping(HOLD)\n    # drivetrain.drive(FORWARD)\n    # wait(1.2, SECONDS)\n    # drivetrain.stop()\n\n    #grab Stake\n    travelDistance = -15\n    numberOfDegrees = (travelDistance/wheelCircumference) * 360\n    drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n    pistonIn()\n    Ramp_Motor.spin(REVERSE)\n    spinDirection = 1\n    rampSpinning = True\n    wait(.4, SECONDS)\n    print(\"Rings On Stake = \", ringsOnStake)\n    wait(1.5, SECONDS)\n    Ramp_Motor.spin_for(FORWARD, 160, DEGREES)\n    spinDirection = -1\n    Ramp_Motor.spin(REVERSE)\n    spinDirection = 1\n    wait(.4, SECONDS)\n    # Ramp_Motor.spin_for(FORWARD, 160, DEGREES)\n    # spinDirection = -1\n    # Ramp_Motor.spin(REVERSE)\n    # spinDirection = 1\n    # wait(.4, SECONDS)\n\n    #turn to ring 2\n    turn_by_angle(-30,speed)\n    wait(.1, SECONDS)\n    intakeIn()\n    wait(0.2, SECONDS)\n    \n    # #move to ring 2\n    numberOfDegrees = (8/wheelCircumference) * 360\n    drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n    wait(.1, SECONDS)\n    print(\"Rings On Stake = \", ringsOnStake)\n    \n    ringIntake = False\n    # #turn to ring 3\n    turn_by_angle(90,speed)\n\n    numberOfDegrees = (15/wheelCircumference) * 360\n    drive_distance_without_timeout(numberOfDegrees, 40)#speed, 5)\n    print(\"RING 3\")\n\n    redPositiveTurnToPos(31, -46.5) \n    wait(.5, SECONDS)\n    redPositiveTurnToPos(31, -46.5) \n    wait(.5, SECONDS)\n    ForwardToCoords(27, -27)\n    wait(.5, SECONDS)\n    turn_by_angle(20, speed)\n    # brain.program_stop()\n    #turn to ring 3\n    ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    visionTurnToRing(ai_vision_10_objects, 2)\n    wait(.5, SECONDS)\n    #drive to ring 3 BLUE\n    numberOfDegrees = (9/wheelCircumference) * 360\n    drive_distance_with_timeout(numberOfDegrees, 40, 5)#speed, 5)\n    wait(.3, SECONDS)\n    print(\"Rings On Stake = \", ringsOnStake)\n    print(\"RING 3\")\n\n    #reverse away from \n    print(\"RING 3\")\n    numberOfDegrees = (-9/wheelCircumference) * 360\n    drive_distance_with_timeout(numberOfDegrees, 40, 5)#speed, 5)\n    wait(.3, SECONDS) \n    #Turn to Red\n    ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    visionTurnToRing(ai_vision_10_objects, 2)\n    wait(.2, SECONDS)\n    #Drive To Red\n    numberOfDegrees = (12/wheelCircumference) * 360\n    drive_distance_with_timeout(numberOfDegrees, 40, 5)\n    wait(.3, SECONDS)\n    ai_vision_10_objects = ai_vision_10.take_snapshot(AiVision.ALL_AIOBJS)\n    visionTurnToRing(ai_vision_10_objects, 2)\n    wait(.2, SECONDS)\n    #Drive To Red\n    numberOfDegrees = (12/wheelCircumference) * 360\n    drive_distance_with_timeout(numberOfDegrees, 40, 5)\n    print(\"Rings On Stake = \", ringsOnStake)\n    print(\"RING 3\")\n\n\n    wait(5, SECONDS)\n    intake.stop()\n    Ramp_Motor.stop()\n    #END ISOLATION\n\n    print(\"Program complete\")\n\n# Run the main program\nprint(\"running main\")\n#monitor_thread = task.spawn(monitor_motor)\nmain()    ","textLanguage":"python","robotConfig":[{"port":[14,18,12,13,0],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel275in","gear":"ratio6_1","gearRatio":"1:1","direction":"fwd","gyroType":"none","width":"13.125","unit":"in","wheelbase":"11.5","wheelbaseUnit":"in","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[2],"name":"Ramp_Motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[15,20],"name":"intake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[7],"name":"digital_out_g","customName":false,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[8],"name":"digital_out_h","customName":false,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{},"triportSourcePort":22},{"port":[5],"name":"gps_5","customName":false,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"5.5","xOffsetUnit":"in","yOffset":"1.5","yOffsetUnit":"in","thetaOffset":"0"},"triportSourcePort":22},{"port":[21],"name":"Gyro_Sensor","customName":true,"deviceType":"Inertial","deviceClass":"inertial","setting":{},"triportSourcePort":22},{"port":[17],"name":"right_rotation","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"false"},"triportSourcePort":22},{"port":[16],"name":"left_rotation","customName":true,"deviceType":"Rotation","deviceClass":"rotation","setting":{"reversed":"true"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[10],"name":"ai_vision_10","customName":false,"deviceType":"AIVision","deviceClass":"aivision","setting":{"config":"{\"colors\":[],\"codes\":[],\"tags\":false,\"AIObjects\":true,\"AIObjectModel\":[\"Ball(Blue)\",\"Ball(Green)\",\"Ball(Red)\",\"Ring(Blue)\",\"Ring(Green)\",\"Ring(Red)\",\"Cube(Blue)\",\"Cube(Green)\",\"Cube(Red)\"],\"aiModelDropDownValue\":\"2024-2025 High Stakes\"}","isConfigured":"false"},"triportSourcePort":22},{"port":[8],"name":"optical_8","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}